<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flow Diagram Playground</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Floating UI Panel */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 240px;
            z-index: 10;
            max-height: 90vh;
            overflow-y: auto;
        }

        .tool-btn {
            background: #333;
            border: 1px solid #555;
            color: #ddd;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .tool-btn:hover { background: #444; border-color: #777; }
        .tool-btn.active { background: #3b82f6; border-color: #2563eb; color: white; }
        .tool-btn.danger:hover { background: #ef4444; border-color: #dc2626; }
        
        .tool-btn.ai { 
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            border: 1px solid #8b5cf6;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .tool-btn.ai:hover {
            filter: brightness(1.1);
            box-shadow: 0 0 10px rgba(124, 58, 237, 0.3);
        }

        .divider { height: 1px; background: #444; margin: 4px 0; }

        #status-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .modal-input {
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0 20px 0;
            font-size: 1rem;
        }
        .modal-input:focus { outline: none; border-color: #3b82f6; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; }
        
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .ai-result-text {
            background: #2d2d2d;
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            color: #e2e8f0;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 16px;
            border-left: 3px solid #7c3aed;
        }
    </style>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- UI Panel -->
    <div id="ui-panel">
        <h1 class="text-lg font-bold text-center mb-2 text-blue-400">FlowBuilder 3D</h1>
        
        <!-- AI Section -->
        <div class="text-xs text-purple-400 font-mono mb-2 uppercase tracking-wider flex items-center gap-2">
            Gemini AI <span class="text-[10px] bg-purple-900 px-1 rounded">NEW</span>
        </div>
        <button class="tool-btn ai" id="ai-generate">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>
            Generate Flow ✨
        </button>
        <button class="tool-btn ai" id="ai-explain">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
            Explain Diagram ✨
        </button>

        <div class="divider"></div>

        <div class="text-xs text-gray-400 font-mono mb-2 uppercase tracking-wider">Create</div>
        <button class="tool-btn" id="add-cube">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
            Add Cube
        </button>
        <button class="tool-btn" id="add-sphere">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>
            Add Sphere
        </button>
        <button class="tool-btn" id="add-text">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3M9 20h6M12 4v16"/></svg>
            Add Label
        </button>
        <button class="tool-btn" id="add-custom">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
            Add Custom
        </button>

        <div class="divider"></div>

        <div class="text-xs text-gray-400 font-mono mb-2 uppercase tracking-wider">Tools</div>
        <button class="tool-btn" id="mode-connect">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
            Link Nodes
        </button>
        <button class="tool-btn danger" id="delete-obj">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
            Delete Selected
        </button>
        
        <div class="mt-2 text-[10px] text-gray-500 leading-tight text-center">
            Select object to move.<br>Press 'R' to toggle Rotate/Translate.
        </div>
    </div>

    <div id="status-bar">Select Source Object...</div>

    <!-- Prompt Modal -->
    <div id="prompt-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2 text-purple-400">Generate Flow ✨</h2>
            <p class="text-sm text-gray-400">Describe the process you want to visualize.</p>
            <input type="text" id="ai-prompt-input" class="modal-input" placeholder="e.g. 'A software login flow' or 'Water cycle'">
            <div class="modal-footer">
                <button class="tool-btn" id="close-prompt">Cancel</button>
                <button class="tool-btn ai" id="confirm-prompt">Generate</button>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="result-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2 text-purple-400">AI Explanation ✨</h2>
            <div id="ai-explanation-text" class="ai-result-text">Loading...</div>
            <div class="modal-footer">
                <button class="tool-btn" id="close-result">Close</button>
            </div>
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Gemini API Setup ---
        const apiKey = ""; // Injected by environment
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

        async function callGemini(promptText, systemInstruction = "") {
            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.statusText}`);
                }

                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No response.";
            } catch (error) {
                console.error("Gemini API Error:", error);
                alert("Failed to call Gemini API. See console for details.");
                return null;
            }
        }

        // --- Core Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- State ---
        const objects = [];
        const arrows = [];
        let selectedObject = null;
        let isConnectMode = false;
        let connectSource = null;

        // --- Controls ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.05;

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', function (event) {
            orbit.enabled = !event.value;
        });
        scene.add(transformControl);

        // --- Materials ---
        const defaultMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.3, metalness: 0.2 });
        const highlightMaterial = new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x059669, emissiveIntensity: 0.5 });
        const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

        // --- Object Creation ---

        function addMesh(geometry, type = 'node', position = null) {
            const x = position ? position.x : (Math.random() - 0.5) * 4;
            const z = position ? position.z : (Math.random() - 0.5) * 4;
            const y = position ? position.y : 2;
            
            const mesh = new THREE.Mesh(geometry, defaultMaterial.clone());
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { type: type, id: Math.random().toString(36).substr(2, 9), label: "" };
            
            scene.add(mesh);
            objects.push(mesh);
            
            return mesh;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.roundRect(10, 10, 492, 108, 30);
            ctx.fill();
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 6;
            ctx.stroke();

            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            return new THREE.CanvasTexture(canvas);
        }

        function addLabel(text, parentMesh = null) {
            const texture = createTextTexture(text);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.scale.set(4, 1, 1);
            sprite.userData = { type: 'label' };

            if (parentMesh) {
                // If attached to a parent, put it slightly above
                sprite.position.set(0, 2, 0);
                parentMesh.add(sprite);
                parentMesh.userData.label = text; // Store text on parent for AI context
            } else {
                // Standalone label
                sprite.position.set(0, 3, 0);
                scene.add(sprite);
                objects.push(sprite);
                selectObject(sprite);
            }
            return sprite;
        }

        // --- Button Listeners ---
        document.getElementById('add-cube').addEventListener('click', () => {
            const mesh = addMesh(new THREE.BoxGeometry(2, 2, 2));
            selectObject(mesh);
        });

        document.getElementById('add-sphere').addEventListener('click', () => {
            const mesh = addMesh(new THREE.SphereGeometry(1.2, 32, 32));
            selectObject(mesh);
        });

        document.getElementById('add-custom').addEventListener('click', () => {
            const mesh = addMesh(new THREE.TorusGeometry(1, 0.4, 16, 100));
            selectObject(mesh);
        });

        document.getElementById('add-text').addEventListener('click', () => {
            const text = prompt("Enter label text:", "Flow Node");
            if (!text) return;
            addLabel(text);
        });

        // --- Connections ---

        function createArrow(source, target) {
            const arrowGroup = new THREE.Group();
            
            const shaftGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            shaftGeo.rotateX(Math.PI / 2);
            shaftGeo.translate(0, 0, 0.5);
            const shaft = new THREE.Mesh(shaftGeo, arrowMaterial);
            
            const headGeo = new THREE.ConeGeometry(0.2, 0.4, 12);
            headGeo.rotateX(Math.PI / 2);
            const head = new THREE.Mesh(headGeo, arrowMaterial);
            
            arrowGroup.add(shaft);
            arrowGroup.add(head);
            
            scene.add(arrowGroup);
            
            arrows.push({
                group: arrowGroup,
                source: source,
                target: target,
                shaft: shaft,
                head: head
            });
        }

        function updateArrows() {
            arrows.forEach(arrow => {
                const start = arrow.source.position.clone();
                const end = arrow.target.position.clone();
                
                // Adjust start/end to account for parent position if they are children (like labels, though we usually connect meshes)
                // Currently we only connect top-level meshes so .position is fine.
                
                const distance = start.distanceTo(end);
                arrow.group.position.copy(start);
                arrow.group.lookAt(end);
                const headLength = 0.4;
                const shaftLength = Math.max(0, distance - headLength);
                arrow.shaft.scale.set(1, 1, shaftLength);
                arrow.head.position.set(0, 0, distance);
            });
        }

        // --- Interaction Logic ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function selectObject(obj) {
            if (selectedObject && selectedObject.userData.type !== 'label') {
                 if(selectedObject !== connectSource) selectedObject.material = defaultMaterial.clone();
            }

            selectedObject = obj;

            if (selectedObject) {
                // If it's a label attached to a parent, don't attach controls to the label itself, but maybe the parent?
                // For now, we only support selecting top level objects or standalone labels
                transformControl.attach(selectedObject);
                if(selectedObject.userData.type !== 'label') {
                   if(selectedObject !== connectSource) selectedObject.material = new THREE.MeshStandardMaterial({ color: 0x60a5fa });
                }
            } else {
                transformControl.detach();
            }
        }

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName !== 'CANVAS') return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const clickedObj = intersects[0].object;
                
                if (isConnectMode) {
                    handleConnectionClick(clickedObj);
                } else {
                    selectObject(clickedObj);
                }
            } else {
                if (!isConnectMode) selectObject(null);
            }
        });

        // Connect Mode
        const connectBtn = document.getElementById('mode-connect');
        const statusBar = document.getElementById('status-bar');

        connectBtn.addEventListener('click', () => {
            isConnectMode = !isConnectMode;
            if (isConnectMode) {
                connectBtn.classList.add('active');
                statusBar.style.opacity = '1';
                statusBar.innerText = "Select Source Object";
                transformControl.detach();
            } else {
                resetConnectMode();
            }
        });

        function handleConnectionClick(obj) {
            // Don't allow connecting to labels for now, just nodes
            if(obj.userData.type === 'label') return;

            if (!connectSource) {
                connectSource = obj;
                obj.material = highlightMaterial;
                statusBar.innerText = "Select Target Object";
            } else {
                if (connectSource !== obj) {
                    createArrow(connectSource, obj);
                    resetConnectMode();
                } else {
                    resetConnectMode();
                }
            }
        }

        function resetConnectMode() {
            isConnectMode = false;
            if (connectSource && connectSource.userData.type !== 'label') {
                connectSource.material = defaultMaterial.clone();
            }
            connectSource = null;
            connectBtn.classList.remove('active');
            statusBar.style.opacity = '0';
            if(selectedObject) transformControl.attach(selectedObject);
        }

        // Delete
        document.getElementById('delete-obj').addEventListener('click', deleteSelected);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if (e.key.toLowerCase() === 'r' && selectedObject) {
                transformControl.setMode(transformControl.mode === 'translate' ? 'rotate' : 'translate');
            }
        });

        function deleteSelected() {
            if (!selectedObject) return;
            scene.remove(selectedObject);
            const index = objects.indexOf(selectedObject);
            if (index > -1) objects.splice(index, 1);
            
            for (let i = arrows.length - 1; i >= 0; i--) {
                if (arrows[i].source === selectedObject || arrows[i].target === selectedObject) {
                    scene.remove(arrows[i].group);
                    arrows.splice(i, 1);
                }
            }
            transformControl.detach();
            selectedObject = null;
        }

        // --- AI Features ---

        // 1. AI Generate Flow
        const promptModal = document.getElementById('prompt-modal');
        const promptInput = document.getElementById('ai-prompt-input');
        const confirmPromptBtn = document.getElementById('confirm-prompt');
        const closePromptBtn = document.getElementById('close-prompt');

        document.getElementById('ai-generate').addEventListener('click', () => {
            promptModal.style.display = 'flex';
            promptInput.focus();
        });

        closePromptBtn.addEventListener('click', () => {
            promptModal.style.display = 'none';
        });

        confirmPromptBtn.addEventListener('click', async () => {
            const userInput = promptInput.value.trim();
            if (!userInput) return;

            // Close modal and show loading state (reuse result modal for loading?)
            promptModal.style.display = 'none';
            
            // Show a simple loading toast or similar? Let's use status bar
            statusBar.style.opacity = '1';
            statusBar.innerHTML = `<span class="loader"></span> Generating Flow...`;

            const systemPrompt = `
                You are a 3D Flow Diagram Generator. 
                The user will ask for a process or system.
                You must return strictly valid JSON (no markdown formatting).
                The JSON must have this structure:
                {
                    "nodes": [ { "label": "Start", "type": "cube" }, { "label": "Step 1", "type": "sphere" } ],
                    "edges": [ { "from": 0, "to": 1 } ]
                }
                "type" can be "cube" or "sphere". 
                Keep labels short (max 3 words).
                Create a logical flow. Limit to 20 nodes max.
            `;

            const resultStr = await callGemini(userInput, systemPrompt);

            if (resultStr) {
                try {
                    // Clean the result string in case model wraps in markdown
                    const cleanJson = resultStr.replace(/```json/g, '').replace(/```/g, '').trim();
                    const data = JSON.parse(cleanJson);
                    
                    buildFlowFromAI(data);
                    statusBar.innerText = "Flow Generated!";
                    setTimeout(() => statusBar.style.opacity = '0', 3000);
                } catch (e) {
                    console.error("Parsing Error", e);
                    alert("Failed to parse AI response. Try again.");
                    statusBar.style.opacity = '0';
                }
            } else {
                statusBar.innerText = "Generation Failed.";
                setTimeout(() => statusBar.style.opacity = '0', 3000);
            }
        });

        function buildFlowFromAI(data) {
            // Clear scene? No, let's append but move camera or offset? 
            // Let's clear scene for a fresh flow to avoid mess.
            while(objects.length > 0) {
                selectedObject = objects[0]; // Hack to use deleteSelected
                deleteSelected();
            }

            const createdMeshes = [];
            const spacingX = 6;
            const spacingZ = 5;
            const columns = 4; // Max width before wrapping

            data.nodes.forEach((node, index) => {
                // Simple Grid Layout
                const col = index % columns;
                const row = Math.floor(index / columns);
                
                const x = (col * spacingX) - (columns * spacingX / 2) + 3;
                const z = (row * spacingZ); // Start at 0 and go down (+Z)
                
                let geo;
                if (node.type === 'sphere') geo = new THREE.SphereGeometry(1.2, 32, 32);
                else geo = new THREE.BoxGeometry(2, 2, 2); // default cube

                const mesh = addMesh(geo, 'node', { x, y: 2, z });
                
                // Add label
                addLabel(node.label, mesh);
                
                createdMeshes.push(mesh);
            });

            // Create connections
            data.edges.forEach(edge => {
                if (createdMeshes[edge.from] && createdMeshes[edge.to]) {
                    createArrow(createdMeshes[edge.from], createdMeshes[edge.to]);
                }
            });
        }

        // 2. AI Explain Flow
        const resultModal = document.getElementById('result-modal');
        const explanationText = document.getElementById('ai-explanation-text');
        const closeResultBtn = document.getElementById('close-result');

        document.getElementById('ai-explain').addEventListener('click', async () => {
            resultModal.style.display = 'flex';
            explanationText.innerHTML = '<span class="loader"></span> Analyzing 3D Scene...';

            // Serialize Scene
            const sceneData = {
                nodes: objects.filter(o => o.userData.type !== 'label').map((o, i) => ({
                    id: o.userData.id,
                    label: o.userData.label || "Unnamed Node",
                    type: o.geometry.type
                })),
                connections: arrows.map(a => ({
                    from: a.source.userData.label || "Unnamed",
                    to: a.target.userData.label || "Unnamed"
                }))
            };

            if (sceneData.nodes.length === 0) {
                explanationText.innerText = "Scene is empty. Add some nodes!";
                return;
            }

            const prompt = `
                Analyze this flow diagram structure and explain what this system/process likely does.
                Nodes: ${JSON.stringify(sceneData.nodes)}
                Connections: ${JSON.stringify(sceneData.connections)}
                
                Provide a concise summary of the flow.
            `;

            const explanation = await callGemini(prompt, "You are a System Architect expert.");
            
            explanationText.innerText = explanation;
        });

        closeResultBtn.addEventListener('click', () => {
            resultModal.style.display = 'none';
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            updateArrows();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
