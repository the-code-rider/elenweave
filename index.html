<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flow Diagram Playground v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Floating UI Panel */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 250px;
            z-index: 10;
            max-height: 90vh;
            overflow-y: auto;
        }

        .tool-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .tool-btn {
            background: #333;
            border: 1px solid #555;
            color: #ddd;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            width: 100%;
        }

        .tool-btn.full-width { grid-column: span 2; }

        .tool-btn:hover { background: #444; border-color: #777; }
        .tool-btn.active { background: #3b82f6; border-color: #2563eb; color: white; }
        .tool-btn.danger:hover { background: #ef4444; border-color: #dc2626; }
        
        .tool-btn.ai { 
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            border: 1px solid #8b5cf6;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .tool-btn.ai:hover {
            filter: brightness(1.1);
            box-shadow: 0 0 10px rgba(124, 58, 237, 0.3);
        }

        .divider { height: 1px; background: #444; margin: 4px 0; }

        .label-sm { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 0.05em; margin-bottom: 2px; }

        /* Color Picker */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #222;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #444;
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }

        #status-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .modal-input {
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0 20px 0;
            font-size: 1rem;
        }
        .modal-input:focus { outline: none; border-color: #3b82f6; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; }
        
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .ai-result-text {
            background: #2d2d2d;
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            color: #e2e8f0;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 16px;
            border-left: 3px solid #7c3aed;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-panel">
        <h1 class="text-lg font-bold text-center text-blue-400">FlowBuilder 2.0</h1>
        
        <!-- AI Section -->
        <div class="label-sm text-purple-400 mt-1">AI Copilot</div>
        <div class="tool-section">
            <button class="tool-btn ai full-width" id="ai-generate">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>
                Generate Flow
            </button>
            <button class="tool-btn ai full-width" id="ai-explain">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                Explain
            </button>
        </div>

        <div class="divider"></div>

        <!-- Properties -->
        <div class="label-sm">Properties</div>
        <div class="color-picker-wrapper">
            <input type="color" id="obj-color" value="#3b82f6">
            <span class="text-xs text-gray-400">Object Color</span>
        </div>

        <div class="divider"></div>

        <!-- Shapes -->
        <div class="label-sm">Shapes</div>
        <div class="tool-section">
            <button class="tool-btn" id="add-cube">Cube</button>
            <button class="tool-btn" id="add-sphere">Sphere</button>
            <button class="tool-btn" id="add-cylinder">DB (Cyl)</button>
            <button class="tool-btn" id="add-diamond">Decision</button>
            <button class="tool-btn" id="add-capsule">Start/End</button>
            <button class="tool-btn" id="add-text">Label</button>
        </div>

        <div class="divider"></div>

        <!-- Tools -->
        <div class="label-sm">Tools</div>
        <div class="tool-section">
            <button class="tool-btn full-width" id="mode-connect">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                Link Nodes
            </button>
            <button class="tool-btn danger full-width" id="delete-obj">
                Delete Selected
            </button>
        </div>
        
        <div class="mt-2 text-[10px] text-gray-500 leading-tight text-center">
            'R' to Rotate/Move.
        </div>
    </div>

    <div id="status-bar">Ready</div>

    <!-- Prompt Modal -->
    <div id="prompt-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2 text-purple-400">Generate Flow ✨</h2>
            <p class="text-sm text-gray-400">Describe the process (e.g., "E-commerce checkout flow").</p>
            <input type="text" id="ai-prompt-input" class="modal-input" placeholder="Enter description...">
            <div class="modal-footer">
                <button class="tool-btn" id="close-prompt">Cancel</button>
                <button class="tool-btn ai" id="confirm-prompt">Generate</button>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="result-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2 text-purple-400">AI Explanation ✨</h2>
            <div id="ai-explanation-text" class="ai-result-text">Loading...</div>
            <div class="modal-footer">
                <button class="tool-btn" id="close-result">Close</button>
            </div>
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Gemini API Setup ---
        const apiKey = ""; 
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

        async function callGemini(promptText, systemInstruction = "") {
            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    })
                });

                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No response.";
            } catch (error) {
                console.error("Gemini API Error:", error);
                return null;
            }
        }

        // --- Core Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- State ---
        const objects = [];
        const arrows = [];
        let selectedObject = null;
        let isConnectMode = false;
        let connectSource = null;

        // --- Controls ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.05;

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', function (event) {
            orbit.enabled = !event.value;
        });
        scene.add(transformControl);

        // --- Materials ---
        const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const highlightEmissive = 0x666666;

        // --- Object Creation ---

        function addMesh(geometry, type = 'cube', position = null, colorHex = '#3b82f6') {
            const x = position ? position.x : (Math.random() - 0.5) * 4;
            const z = position ? position.z : (Math.random() - 0.5) * 4;
            const y = position ? position.y : 2;
            
            // Create specific material for this object so we can change its color individually
            const material = new THREE.MeshStandardMaterial({ 
                color: colorHex, 
                roughness: 0.3, 
                metalness: 0.2 
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Rotate cylinder to stand up if needed, but CylinderGeometry defaults to upright Y-axis.
            // Diamond (Octahedron) needs no rotation usually.
            // Capsule defaults upright.
            
            mesh.userData = { 
                type: type, 
                id: Math.random().toString(36).substr(2, 9), 
                label: "",
                baseColor: colorHex 
            };
            
            scene.add(mesh);
            objects.push(mesh);
            
            return mesh;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.roundRect(10, 10, 492, 108, 30);
            ctx.fill();
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 6;
            ctx.stroke();

            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            return new THREE.CanvasTexture(canvas);
        }

        function addLabel(text, parentMesh = null) {
            const texture = createTextTexture(text);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.scale.set(4, 1, 1);
            sprite.userData = { type: 'label' };

            if (parentMesh) {
                // Calculate height offset based on geometry
                let yOffset = 2;
                if (parentMesh.geometry.type === 'CylinderGeometry') yOffset = 2.5;
                if (parentMesh.geometry.type === 'CapsuleGeometry') yOffset = 2.5;

                sprite.position.set(0, yOffset, 0);
                parentMesh.add(sprite);
                parentMesh.userData.label = text;
            } else {
                sprite.position.set(0, 3, 0);
                scene.add(sprite);
                objects.push(sprite);
                selectObject(sprite);
            }
            return sprite;
        }

        // --- Geometry Helpers ---
        document.getElementById('add-cube').addEventListener('click', () => {
            const mesh = addMesh(new THREE.BoxGeometry(2, 2, 2), 'cube', null, document.getElementById('obj-color').value);
            selectObject(mesh);
        });
        document.getElementById('add-sphere').addEventListener('click', () => {
            const mesh = addMesh(new THREE.SphereGeometry(1.2, 32, 32), 'sphere', null, document.getElementById('obj-color').value);
            selectObject(mesh);
        });
        document.getElementById('add-cylinder').addEventListener('click', () => {
            // Database shape
            const mesh = addMesh(new THREE.CylinderGeometry(1, 1, 2.5, 32), 'cylinder', null, document.getElementById('obj-color').value);
            selectObject(mesh);
        });
        document.getElementById('add-diamond').addEventListener('click', () => {
            // Decision shape (Octahedron looks like a 3D diamond)
            const mesh = addMesh(new THREE.OctahedronGeometry(1.5, 0), 'diamond', null, document.getElementById('obj-color').value);
            selectObject(mesh);
        });
        document.getElementById('add-capsule').addEventListener('click', () => {
            // Start/End shape
            const mesh = addMesh(new THREE.CapsuleGeometry(0.8, 1, 4, 16), 'capsule', null, document.getElementById('obj-color').value);
            selectObject(mesh);
        });
        document.getElementById('add-text').addEventListener('click', () => {
            const text = prompt("Enter label text:", "Node");
            if (!text) return;
            addLabel(text);
        });

        // --- Color Picker Logic ---
        const colorPicker = document.getElementById('obj-color');
        colorPicker.addEventListener('input', (e) => {
            const hex = e.target.value;
            if (selectedObject && selectedObject.userData.type !== 'label') {
                selectedObject.material.color.set(hex);
                selectedObject.userData.baseColor = hex; // Update stored base color
            }
        });

        // --- Connections ---

        function createArrow(source, target) {
            const arrowGroup = new THREE.Group();
            
            const shaftGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
            shaftGeo.rotateX(Math.PI / 2);
            shaftGeo.translate(0, 0, 0.5);
            const shaft = new THREE.Mesh(shaftGeo, arrowMaterial);
            
            const headGeo = new THREE.ConeGeometry(0.2, 0.4, 12);
            headGeo.rotateX(Math.PI / 2);
            const head = new THREE.Mesh(headGeo, arrowMaterial);
            
            arrowGroup.add(shaft);
            arrowGroup.add(head);
            
            scene.add(arrowGroup);
            
            arrows.push({
                group: arrowGroup,
                source: source,
                target: target,
                shaft: shaft,
                head: head
            });
        }

        function updateArrows() {
            arrows.forEach(arrow => {
                const start = arrow.source.position.clone();
                const end = arrow.target.position.clone();
                const distance = start.distanceTo(end);
                arrow.group.position.copy(start);
                arrow.group.lookAt(end);
                const headLength = 0.4;
                const shaftLength = Math.max(0, distance - headLength);
                arrow.shaft.scale.set(1, 1, shaftLength);
                arrow.head.position.set(0, 0, distance);
            });
        }

        // --- Interaction Logic ---

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function selectObject(obj) {
            // Deselect previous
            if (selectedObject && selectedObject.userData.type !== 'label') {
                if (selectedObject !== connectSource) {
                    selectedObject.material.emissive.setHex(0x000000); // Turn off glow
                }
            }

            selectedObject = obj;

            if (selectedObject) {
                transformControl.attach(selectedObject);
                
                // Handle color picker update
                if (selectedObject.userData.type !== 'label') {
                     // Highlight current selection
                    if (selectedObject !== connectSource) {
                        selectedObject.material.emissive.setHex(0x333333); // Subtle glow
                    }
                    // Sync color picker
                    colorPicker.value = '#' + selectedObject.material.color.getHexString();
                }
            } else {
                transformControl.detach();
            }
        }

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName !== 'CANVAS') return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const clickedObj = intersects[0].object;
                if (isConnectMode) {
                    handleConnectionClick(clickedObj);
                } else {
                    selectObject(clickedObj);
                }
            } else {
                if (!isConnectMode) selectObject(null);
            }
        });

        // Connect Mode
        const connectBtn = document.getElementById('mode-connect');
        const statusBar = document.getElementById('status-bar');

        connectBtn.addEventListener('click', () => {
            isConnectMode = !isConnectMode;
            if (isConnectMode) {
                connectBtn.classList.add('active');
                statusBar.style.opacity = '1';
                statusBar.innerText = "Select Source Node";
                transformControl.detach();
            } else {
                resetConnectMode();
            }
        });

        function handleConnectionClick(obj) {
            if(obj.userData.type === 'label') return; // No connecting labels

            if (!connectSource) {
                connectSource = obj;
                obj.material.emissive.setHex(0x00ff00); // Strong green glow
                statusBar.innerText = "Select Target Node";
            } else {
                if (connectSource !== obj) {
                    createArrow(connectSource, obj);
                    resetConnectMode();
                } else {
                    resetConnectMode();
                }
            }
        }

        function resetConnectMode() {
            isConnectMode = false;
            if (connectSource && connectSource.userData.type !== 'label') {
                connectSource.material.emissive.setHex(0x000000); // Reset glow
            }
            connectSource = null;
            connectBtn.classList.remove('active');
            statusBar.style.opacity = '0';
            if(selectedObject) {
                transformControl.attach(selectedObject);
                if (selectedObject.userData.type !== 'label') selectedObject.material.emissive.setHex(0x333333);
            }
        }

        // Delete
        document.getElementById('delete-obj').addEventListener('click', deleteSelected);
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
            if (e.key.toLowerCase() === 'r' && selectedObject) {
                transformControl.setMode(transformControl.mode === 'translate' ? 'rotate' : 'translate');
            }
        });

        function deleteSelected() {
            if (!selectedObject) return;
            scene.remove(selectedObject);
            const index = objects.indexOf(selectedObject);
            if (index > -1) objects.splice(index, 1);
            
            for (let i = arrows.length - 1; i >= 0; i--) {
                if (arrows[i].source === selectedObject || arrows[i].target === selectedObject) {
                    scene.remove(arrows[i].group);
                    arrows.splice(i, 1);
                }
            }
            transformControl.detach();
            selectedObject = null;
        }

        // --- AI Features ---

        const promptModal = document.getElementById('prompt-modal');
        const promptInput = document.getElementById('ai-prompt-input');
        const confirmPromptBtn = document.getElementById('confirm-prompt');
        const closePromptBtn = document.getElementById('close-prompt');

        document.getElementById('ai-generate').addEventListener('click', () => {
            promptModal.style.display = 'flex';
            promptInput.focus();
        });

        closePromptBtn.addEventListener('click', () => { promptModal.style.display = 'none'; });

        confirmPromptBtn.addEventListener('click', async () => {
            const userInput = promptInput.value.trim();
            if (!userInput) return;
            promptModal.style.display = 'none';
            statusBar.style.opacity = '1';
            statusBar.innerHTML = `<span class="loader"></span> Designing Flow...`;

            const systemPrompt = `
                You are a 3D Flow Diagram Architect. Return strictly valid JSON.
                
                Shapes/Types:
                - "cube" (Standard Process/Step)
                - "sphere" (State/Entity)
                - "cylinder" (Database/Storage)
                - "diamond" (Decision/Gateway)
                - "capsule" (Start/End/Terminator)

                Colors (Hex):
                - Use Semantic Colors (e.g., #ef4444 for Errors, #22c55e for Success, #3b82f6 for default, #eab308 for warnings).
                
                Schema:
                {
                    "nodes": [ { "label": "Start", "type": "capsule", "color": "#22c55e" } ],
                    "edges": [ { "from": 0, "to": 1 } ]
                }
                Limit to 12 nodes.
            `;

            const resultStr = await callGemini(userInput, systemPrompt);

            if (resultStr) {
                try {
                    const cleanJson = resultStr.replace(/```json/g, '').replace(/```/g, '').trim();
                    const data = JSON.parse(cleanJson);
                    buildFlowFromAI(data);
                    statusBar.innerText = "Flow Generated!";
                    setTimeout(() => statusBar.style.opacity = '0', 3000);
                } catch (e) {
                    console.error(e);
                    alert("AI Error. See console.");
                    statusBar.style.opacity = '0';
                }
            } else {
                statusBar.innerText = "Generation Failed.";
            }
        });

        function buildFlowFromAI(data) {
            while(objects.length > 0) { selectedObject = objects[0]; deleteSelected(); }

            const createdMeshes = [];
            const spacingX = 6;
            const spacingZ = 5;
            const columns = 3; 

            data.nodes.forEach((node, index) => {
                const col = index % columns;
                const row = Math.floor(index / columns);
                
                // Staggered grid
                const x = (col * spacingX) - ((columns * spacingX) / 2) + (row % 2 === 0 ? 0 : 3);
                const z = (row * spacingZ) - 5;
                
                let geo;
                switch(node.type) {
                    case 'sphere': geo = new THREE.SphereGeometry(1.2, 32, 32); break;
                    case 'cylinder': geo = new THREE.CylinderGeometry(1, 1, 2.5, 32); break;
                    case 'diamond': geo = new THREE.OctahedronGeometry(1.5, 0); break;
                    case 'capsule': geo = new THREE.CapsuleGeometry(0.8, 1, 4, 16); break;
                    default: geo = new THREE.BoxGeometry(2, 2, 2); break;
                }

                const mesh = addMesh(geo, node.type, { x, y: 2, z }, node.color || '#3b82f6');
                addLabel(node.label, mesh);
                createdMeshes.push(mesh);
            });

            data.edges.forEach(edge => {
                if (createdMeshes[edge.from] && createdMeshes[edge.to]) {
                    createArrow(createdMeshes[edge.from], createdMeshes[edge.to]);
                }
            });
        }

        // Explain Logic
        const resultModal = document.getElementById('result-modal');
        const explanationText = document.getElementById('ai-explanation-text');
        const closeResultBtn = document.getElementById('close-result');

        document.getElementById('ai-explain').addEventListener('click', async () => {
            resultModal.style.display = 'flex';
            explanationText.innerHTML = '<span class="loader"></span> Analyzing Architecture...';

            const sceneData = {
                nodes: objects.filter(o => o.userData.type !== 'label').map(o => ({
                    label: o.userData.label || "Unnamed",
                    type: o.userData.type,
                    color: o.userData.baseColor
                })),
                connections: arrows.map(a => ({
                    from: a.source.userData.label,
                    to: a.target.userData.label
                }))
            };

            if (sceneData.nodes.length === 0) {
                explanationText.innerText = "Canvas is empty.";
                return;
            }

            const prompt = `
                Analyze this 3D architecture diagram.
                Nodes (includes shape & color): ${JSON.stringify(sceneData.nodes)}
                Connections: ${JSON.stringify(sceneData.connections)}
                
                Interpret the colors (e.g., Red often means error/stop, Green start/success) and shapes (Cylinders=Databases, Diamonds=Decisions).
                Explain the flow's logic.
            `;

            const explanation = await callGemini(prompt, "You are a Senior System Architect.");
            explanationText.innerText = explanation;
        });

        closeResultBtn.addEventListener('click', () => { resultModal.style.display = 'none'; });

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            orbit.update();
            updateArrows();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>