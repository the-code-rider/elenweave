<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flow Diagram Playground v6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Floating UI Panel */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 260px;
            z-index: 10;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Top Right Info Panel */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            color: #e0e0e0;
            z-index: 10;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            overflow: hidden;
        }
        .info-header {
            background: #333;
            padding: 8px 12px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            border-bottom: 1px solid #444;
            color: #a0aec0;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .info-content {
            padding: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            color: #a5f3fc; /* Cyan tint for code */
        }

        .tool-section { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

        .tool-btn {
            background: #333;
            border: 1px solid #555;
            color: #ddd;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            width: 100%;
        }
        .tool-btn.full-width { grid-column: span 2; }
        .tool-btn:hover { background: #444; border-color: #777; }
        .tool-btn.active { background: #3b82f6; border-color: #2563eb; color: white; }
        .tool-btn.danger:hover { background: #ef4444; border-color: #dc2626; }
        
        .tool-btn.ai { 
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            border: 1px solid #8b5cf6;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .tool-btn.ai:hover { filter: brightness(1.1); box-shadow: 0 0 10px rgba(124, 58, 237, 0.3); }

        /* Animation Controls */
        .anim-controls { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; }
        .tool-btn.play { background: #059669; border-color: #047857; color: white; }
        .tool-btn.pause { background: #d97706; border-color: #b45309; color: white; }
        .tool-btn.stop { background: #dc2626; border-color: #b91c1c; color: white; }

        .divider { height: 1px; background: #444; margin: 4px 0; }
        .label-sm { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 0.05em; margin-bottom: 2px; }

        .prop-row {
            display: flex; align-items: center; justify-content: space-between;
            background: #222; padding: 8px; border-radius: 6px; border: 1px solid #444;
        }
        input[type="color"] { -webkit-appearance: none; border: none; width: 24px; height: 24px; border-radius: 4px; cursor: pointer; background: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }

        /* Toggle Switch */
        .toggle-switch { position: relative; display: inline-block; width: 34px; height: 18px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #f97316; }
        input:checked + .slider:before { transform: translateX(16px); }

        /* Diagram Select */
        select.diagram-select {
            width: 100%;
            background: #222; color: #eee; border: 1px solid #444;
            padding: 6px; border-radius: 4px; font-size: 0.8rem; outline: none; margin-bottom: 6px;
        }

        #status-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); padding: 8px 16px; border-radius: 20px;
            font-size: 0.9rem; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 20;
        }

        #subtitle-overlay {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px);
            padding: 16px 24px; border-radius: 8px; font-size: 1.1rem; color: #fff;
            text-align: center; max-width: 600px; border: 1px solid rgba(255,255,255,0.2);
            display: none; z-index: 15; box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); z-index: 100; align-items: center; justify-content: center; backdrop-filter: blur(4px);
        }
        .modal-content {
            background: #1e1e1e; border: 1px solid #444; border-radius: 12px; padding: 24px;
            width: 90%; max-width: 500px; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .modal-input {
            width: 100%; background: #333; border: 1px solid #555; color: white; padding: 10px;
            border-radius: 6px; margin: 10px 0 20px 0; font-size: 1rem;
        }
        .modal-input:focus { outline: none; border-color: #3b82f6; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; }
        
        .loader {
            border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 20px; height: 20px;
            animation: spin 1s linear infinite; display: inline-block; margin-right: 8px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-panel">
        <h1 class="text-lg font-bold text-center text-blue-400">FlowBuilder 6.0</h1>
        
        <!-- AI Section -->
        <div class="label-sm text-purple-400 mt-1">AI Director</div>
        <div class="tool-section">
            <button class="tool-btn ai full-width" id="ai-generate-btn">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>
                Generate Flow
            </button>
            <button class="tool-btn ai full-width" id="ai-explain-btn">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                Explain Active
            </button>
        </div>

        <div class="divider"></div>

        <!-- Diagram List -->
        <div class="label-sm text-blue-300">Active Diagram</div>
        <select id="diagram-select" class="diagram-select">
            <option value="manual">Manual Canvas</option>
        </select>
        
        <div class="label-sm text-orange-300" id="expl-label" style="display:none">Explanation View</div>
        <select id="explanation-select" class="diagram-select" style="display:none">
            <option value="main">Main Flow</option>
        </select>

        <div class="divider"></div>

        <!-- Animation Controls -->
        <div class="label-sm text-green-400">Animation</div>
        <div class="anim-controls">
            <button class="tool-btn play" id="anim-play" title="Play">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            </button>
            <button class="tool-btn pause" id="anim-pause" title="Pause">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
            </button>
            <button class="tool-btn stop" id="anim-stop" title="Stop">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12"></rect></svg>
            </button>
        </div>

        <div class="divider"></div>

        <!-- Properties -->
        <div class="label-sm">Properties</div>
        <div class="prop-row">
            <span class="text-xs text-gray-400">Object Color</span>
            <input type="color" id="obj-color" value="#3b82f6">
        </div>

        <div class="divider"></div>

        <!-- Shapes -->
        <div class="label-sm">Shapes</div>
        <div class="tool-section">
            <button class="tool-btn" id="add-cube">Cube</button>
            <button class="tool-btn" id="add-sphere">Sphere</button>
            <button class="tool-btn" id="add-cylinder">DB</button>
            <button class="tool-btn" id="add-diamond">Decision</button>
            <button class="tool-btn" id="add-capsule">Start/End</button>
            <button class="tool-btn" id="add-text">Label</button>
        </div>

        <div class="divider"></div>

        <!-- Tools -->
        <div class="label-sm">Tools</div>
        <div class="tool-section">
            <button class="tool-btn full-width" id="mode-connect">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                Link Nodes
            </button>
            <button class="tool-btn danger full-width" id="delete-obj">
                Delete Selected
            </button>
        </div>
    </div>

    <div id="info-panel">
        <div class="info-header">Node Context / Code</div>
        <div class="info-content" id="info-content">Select a node or play animation...</div>
    </div>

    <div id="status-bar">Ready</div>
    <div id="subtitle-overlay"></div>

    <!-- Prompt Modal -->
    <div id="prompt-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2 text-purple-400" id="modal-title">Generate Flow âœ¨</h2>
            <p class="text-sm text-gray-400" id="modal-desc">Describe the process (e.g., "E-commerce checkout flow").</p>
            <input type="text" id="ai-prompt-input" class="modal-input" placeholder="Enter description...">
            <div class="modal-footer">
                <button class="tool-btn" id="close-prompt">Cancel</button>
                <button class="tool-btn ai" id="confirm-prompt">Go</button>
            </div>
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Gemini API Setup ---
        const apiKey = ""; 
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

        async function callGemini(promptText, systemInstruction = "") {
            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    })
                });

                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No response.";
            } catch (error) {
                console.error("Gemini API Error:", error);
                return null;
            }
        }

        // --- Core Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const gridHelper = new THREE.GridHelper(500, 500, 0x444444, 0x222222);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- State ---
        const objects = [];
        const arrows = [];
        let selectedObject = null;
        let isConnectMode = false;
        let connectSource = null;
        
        // Diagram State
        // { id, name, offsetX, mainSequence: [], explanations: [ { id, query, sequence: [], nodeIds: [] } ] }
        const diagrams = []; 
        let activeDiagramId = "manual";
        let activeExplanationId = "main"; // "main" or explanation ID
        let nextDiagramOffsetX = 0;

        // Animation State
        let animState = {
            isPlaying: false,
            isPaused: false,
            currentIndex: 0,
            sequence: [], // Active sequence
            cameraStartPos: new THREE.Vector3(),
            cameraStartTarget: new THREE.Vector3(),
            targetPos: new THREE.Vector3(),
            targetLookAt: new THREE.Vector3(),
            lastStepTime: 0,
            phase: 'IDLE'
        };

        // --- Controls ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.05;

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', function (event) {
            orbit.enabled = !event.value;
        });
        scene.add(transformControl);

        // --- Materials ---
        const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4 });
        const arrowHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.2 });

        // --- Object Creation ---

        function addMesh(geometry, type = 'cube', position = null, colorHex = '#3b82f6', category = 'standard', diagramId = 'manual', explanationId = null) {
            const x = position ? position.x : (Math.random() - 0.5) * 4;
            const z = position ? position.z : (Math.random() - 0.5) * 4;
            // Standard nodes at 2, Explain at 8
            const defaultY = category === 'explain' ? 8 : 2;
            const y = position && position.y !== undefined ? position.y : defaultY;
            
            const material = new THREE.MeshStandardMaterial({ 
                color: colorHex, 
                roughness: 0.3, 
                metalness: 0.2 
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = { 
                type: type, 
                id: Math.random().toString(36).substr(2, 9), 
                label: "",
                baseColor: colorHex,
                category: category,
                diagramId: diagramId,
                explanationId: explanationId // Track which explanation spawned this
            };
            
            scene.add(mesh);
            objects.push(mesh);
            
            updateVisibility(); // Re-check visibility
            
            return mesh;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.0)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; ctx.beginPath(); ctx.roundRect(10, 10, 492, 108, 30); ctx.fill();
            ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 6; ctx.stroke();
            ctx.font = 'bold 60px Arial'; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            return new THREE.CanvasTexture(canvas);
        }

        function addLabel(text, parentMesh = null) {
            const texture = createTextTexture(text);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(4, 1, 1);
            sprite.userData = { type: 'label' };
            if (parentMesh) {
                let yOffset = 2;
                if (parentMesh.geometry.type === 'CylinderGeometry') yOffset = 2.5;
                if (parentMesh.geometry.type === 'CapsuleGeometry') yOffset = 2.5;
                if (parentMesh.userData.category === 'explain') yOffset = 2;
                sprite.position.set(0, yOffset, 0);
                parentMesh.add(sprite);
                parentMesh.userData.label = text;
            } else {
                sprite.position.set(0, 3, 0); scene.add(sprite); objects.push(sprite); selectObject(sprite);
            }
            return sprite;
        }

        // --- Helpers ---
        document.getElementById('add-cube').addEventListener('click', () => addMesh(new THREE.BoxGeometry(2, 2, 2), 'cube', null, document.getElementById('obj-color').value, 'standard', activeDiagramId));
        document.getElementById('add-sphere').addEventListener('click', () => addMesh(new THREE.SphereGeometry(1.2, 32, 32), 'sphere', null, document.getElementById('obj-color').value, 'standard', activeDiagramId));
        document.getElementById('add-cylinder').addEventListener('click', () => addMesh(new THREE.CylinderGeometry(1, 1, 2.5, 32), 'cylinder', null, document.getElementById('obj-color').value, 'standard', activeDiagramId));
        document.getElementById('add-diamond').addEventListener('click', () => addMesh(new THREE.OctahedronGeometry(1.5, 0), 'diamond', null, document.getElementById('obj-color').value, 'standard', activeDiagramId));
        document.getElementById('add-capsule').addEventListener('click', () => addMesh(new THREE.CapsuleGeometry(0.8, 1, 4, 16), 'capsule', null, document.getElementById('obj-color').value, 'standard', activeDiagramId));
        document.getElementById('add-text').addEventListener('click', () => { const text = prompt("Enter label text:", "Node"); if (text) addLabel(text); });

        // --- Connections ---
        function createArrow(source, target) {
            const arrowGroup = new THREE.Group();
            const shaftGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
            shaftGeo.rotateX(Math.PI / 2); shaftGeo.translate(0, 0, 0.5);
            const shaft = new THREE.Mesh(shaftGeo, arrowMaterial);
            const headGeo = new THREE.ConeGeometry(0.35, 0.8, 12);
            headGeo.rotateX(Math.PI / 2);
            const head = new THREE.Mesh(headGeo, arrowHeadMaterial);
            arrowGroup.add(shaft); arrowGroup.add(head); scene.add(arrowGroup);
            
            arrowGroup.userData = { category: source.userData.category || 'standard', explanationId: source.userData.explanationId };
            arrows.push({ group: arrowGroup, source, target, shaft, head });
            updateVisibility();
        }

        function updateArrows() {
            arrows.forEach(arrow => {
                // If connected nodes hidden, hide arrow
                if (!arrow.source.parent || !arrow.target.parent || !arrow.source.visible || !arrow.target.visible) {
                    arrow.group.visible = false;
                    return;
                }
                // If nodes are visible, arrow is visible
                arrow.group.visible = true;

                const start = arrow.source.position.clone();
                const end = arrow.target.position.clone();
                const distance = start.distanceTo(end);
                arrow.group.position.copy(start);
                arrow.group.lookAt(end);
                const headLength = 0.8;
                const shaftLength = Math.max(0, distance - headLength);
                arrow.shaft.scale.set(1, 1, shaftLength);
                arrow.head.position.set(0, 0, distance - (headLength * 0.5));
            });
        }

        // --- UI Logic: Visibilty & Selection ---
        const diagramSelect = document.getElementById('diagram-select');
        const explanationSelect = document.getElementById('explanation-select');
        const explLabel = document.getElementById('expl-label');

        function updateVisibility() {
            objects.forEach(obj => {
                // 1. Check Diagram
                if (obj.userData.diagramId !== activeDiagramId) {
                    obj.visible = false;
                    return;
                }

                // 2. Check Explanation
                // Standard nodes always show for active diagram
                if (obj.userData.category === 'standard') {
                    obj.visible = true;
                    return;
                }

                // Explain nodes: only show if they belong to active explanation
                if (obj.userData.category === 'explain') {
                    if (activeExplanationId !== 'main' && obj.userData.explanationId === activeExplanationId) {
                        obj.visible = true;
                    } else {
                        obj.visible = false;
                    }
                }
            });
        }

        diagramSelect.addEventListener('change', (e) => {
            activeDiagramId = e.target.value;
            activeExplanationId = 'main'; // Reset to main
            
            updateExplanationUI();
            updateCameraAndSequence();
            updateVisibility();
        });

        explanationSelect.addEventListener('change', (e) => {
            activeExplanationId = e.target.value;
            updateCameraAndSequence();
            updateVisibility();
        });

        function updateExplanationUI() {
            const diag = diagrams.find(d => d.id === activeDiagramId);
            explanationSelect.innerHTML = `<option value="main">Main Flow</option>`;
            
            if (diag && diag.explanations.length > 0) {
                explLabel.style.display = 'block';
                explanationSelect.style.display = 'block';
                diag.explanations.forEach(ex => {
                    const opt = document.createElement('option');
                    opt.value = ex.id;
                    opt.text = ex.query.substring(0, 25) + "...";
                    explanationSelect.appendChild(opt);
                });
            } else {
                explLabel.style.display = 'none';
                explanationSelect.style.display = 'none';
            }
            explanationSelect.value = activeExplanationId;
        }

        function updateCameraAndSequence() {
            const diag = diagrams.find(d => d.id === activeDiagramId);
            if (!diag) return;

            // 1. Determine Active Sequence
            if (activeExplanationId === 'main') {
                animState.sequence = diag.mainSequence || [];
            } else {
                const exp = diag.explanations.find(e => e.id === activeExplanationId);
                animState.sequence = exp ? exp.sequence : [];
            }

            stopAnimation();

            // 2. Move Camera (if diagram changed, but we are already handling activeDiagramId logic)
            const targetX = diag.offsetX || 0;
            const destPos = new THREE.Vector3(targetX + 15, 15, 15);
            const destLook = new THREE.Vector3(targetX, 0, 0);
            camera.position.copy(destPos);
            orbit.target.copy(destLook);
        }

        // --- Interaction ---
        const colorPicker = document.getElementById('obj-color');
        colorPicker.addEventListener('input', (e) => {
            if (selectedObject && selectedObject.userData.type !== 'label') {
                selectedObject.material.color.set(e.target.value);
                selectedObject.userData.baseColor = e.target.value;
            }
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const infoPanel = document.getElementById('info-panel');
        const infoContent = document.getElementById('info-content');
        const subtitleOverlay = document.getElementById('subtitle-overlay');

        function selectObject(obj) {
            if (selectedObject && selectedObject.userData.type !== 'label' && selectedObject !== connectSource) {
                selectedObject.material.emissive.setHex(0x000000);
            }
            selectedObject = obj;
            
            // Clear Info if deselected
            if(!selectedObject) {
                transformControl.detach();
                infoPanel.style.display = 'none';
                subtitleOverlay.style.display = 'none';
                return;
            }

            transformControl.attach(selectedObject);
            
            if (selectedObject.userData.type !== 'label') {
                if (selectedObject !== connectSource) selectedObject.material.emissive.setHex(0x333333);
                colorPicker.value = '#' + selectedObject.material.color.getHexString();
            }

            // --- Smart Info Lookup ---
            // Check if this node has info in the ACTIVE animation sequence
            const relatedStep = animState.sequence.find(step => step.targetId === obj.userData.id);
            
            if (relatedStep) {
                infoPanel.style.display = 'block';
                subtitleOverlay.style.display = 'block'; // Also show subtitle to give context
                infoContent.innerText = relatedStep.codeSnippet || "// No code attached";
                subtitleOverlay.innerText = relatedStep.text || "";
            } else {
                // Fallback info
                infoPanel.style.display = 'block';
                infoContent.innerText = `ID: ${obj.userData.id}\nLabel: ${obj.userData.label || 'None'}\n// No specific script found for this context`;
                subtitleOverlay.style.display = 'none';
            }
        }

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName !== 'CANVAS') return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects.filter(o => o.visible)); 
            if (intersects.length > 0) {
                if (isConnectMode) handleConnectionClick(intersects[0].object);
                else selectObject(intersects[0].object);
            } else {
                if (!isConnectMode) selectObject(null);
            }
        });

        const connectBtn = document.getElementById('mode-connect');
        const statusBar = document.getElementById('status-bar');
        connectBtn.addEventListener('click', () => {
            isConnectMode = !isConnectMode;
            if (isConnectMode) {
                connectBtn.classList.add('active');
                statusBar.style.opacity = '1';
                statusBar.innerText = "Select Source Node";
                transformControl.detach();
            } else {
                resetConnectMode();
            }
        });

        function handleConnectionClick(obj) {
            if(obj.userData.type === 'label') return;
            if (!connectSource) {
                connectSource = obj;
                obj.material.emissive.setHex(0x00ff00);
                statusBar.innerText = "Select Target Node";
            } else {
                if (connectSource !== obj) {
                    createArrow(connectSource, obj);
                    resetConnectMode();
                } else resetConnectMode();
            }
        }

        function resetConnectMode() {
            isConnectMode = false;
            if (connectSource && connectSource.userData.type !== 'label') connectSource.material.emissive.setHex(0x000000);
            connectSource = null;
            connectBtn.classList.remove('active');
            statusBar.style.opacity = '0';
            if(selectedObject) transformControl.attach(selectedObject);
        }

        // --- Animation Logic ---
        const playBtn = document.getElementById('anim-play');
        const pauseBtn = document.getElementById('anim-pause');
        const stopBtn = document.getElementById('anim-stop');

        playBtn.addEventListener('click', startAnimation);
        pauseBtn.addEventListener('click', () => { animState.isPaused = !animState.isPaused; });
        stopBtn.addEventListener('click', stopAnimation);

        function startAnimation() {
            if (animState.sequence.length === 0) {
                // Fallback gen for manual
                 animState.sequence = objects
                    .filter(o => o.userData.type !== 'label' && o.visible && o.userData.diagramId === activeDiagramId)
                    .map(o => ({ 
                        targetId: o.userData.id, duration: 1500, hold: 1000, text: o.userData.label || "Node", codeSnippet: "// Manual Node" 
                    }));
            }
            
            if (animState.sequence.length === 0) {
                statusBar.innerText = "No animation steps found.";
                statusBar.style.opacity = '1';
                setTimeout(() => statusBar.style.opacity = '0', 2000);
                return;
            }

            if (!animState.isPlaying) {
                animState.isPlaying = true;
                animState.isPaused = false;
                animState.currentIndex = 0;
                orbit.enabled = false;
                transformControl.detach();
                subtitleOverlay.style.display = 'block';
                infoPanel.style.display = 'block';
                prepareStep(0);
            } else if (animState.isPaused) {
                animState.isPaused = false;
            }
        }

        function stopAnimation() {
            animState.isPlaying = false;
            animState.isPaused = false;
            orbit.enabled = true;
            subtitleOverlay.style.display = 'none';
            infoPanel.style.display = 'none';
            statusBar.innerText = "Ready";
            statusBar.style.opacity = '0';
        }

        function prepareStep(index) {
            if (index >= animState.sequence.length) {
                stopAnimation();
                return;
            }

            const step = animState.sequence[index];
            const targetObj = objects.find(o => o.userData.id === step.targetId);

            if (!targetObj || !targetObj.visible) {
                // Skip invisible steps
                prepareStep(index + 1);
                return;
            }

            animState.cameraStartPos.copy(camera.position);
            animState.cameraStartTarget.copy(orbit.target);
            
            const offset = new THREE.Vector3(5, 5, 5); 
            animState.targetPos.copy(targetObj.position).add(offset);
            animState.targetLookAt.copy(targetObj.position);
            
            animState.phase = 'MOVING';
            animState.lastStepTime = Date.now();
            
            subtitleOverlay.innerText = step.text;
            infoContent.innerText = step.codeSnippet || "// No details available";
            statusBar.style.opacity = '1';
            statusBar.innerText = `Step ${index + 1}/${animState.sequence.length}`;
            selectObject(targetObj);
        }

        function updateAnimation() {
            if (!animState.isPlaying || animState.isPaused) return;

            const now = Date.now();
            const step = animState.sequence[animState.currentIndex];
            const elapsed = now - animState.lastStepTime;

            if (animState.phase === 'MOVING') {
                const progress = Math.min(elapsed / step.duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3);
                camera.position.lerpVectors(animState.cameraStartPos, animState.targetPos, ease);
                orbit.target.lerpVectors(animState.cameraStartTarget, animState.targetLookAt, ease);
                if (progress >= 1) {
                    animState.phase = 'HOLDING';
                    animState.lastStepTime = now;
                }
            } else if (animState.phase === 'HOLDING') {
                if (elapsed >= step.hold) {
                    animState.currentIndex++;
                    prepareStep(animState.currentIndex);
                }
            }
        }

        // --- AI Features ---
        const promptModal = document.getElementById('prompt-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalDesc = document.getElementById('modal-desc');
        const promptInput = document.getElementById('ai-prompt-input');
        const confirmPromptBtn = document.getElementById('confirm-prompt');
        const closePromptBtn = document.getElementById('close-prompt');
        
        let currentAiMode = 'generate'; 

        document.getElementById('ai-generate-btn').addEventListener('click', () => {
            currentAiMode = 'generate';
            modalTitle.innerText = "Generate Flow âœ¨";
            modalTitle.className = "text-xl font-bold mb-2 text-purple-400";
            modalDesc.innerText = "Creates a NEW diagram (appended to scene).";
            promptModal.style.display = 'flex';
            promptInput.value = "";
            promptInput.focus();
        });

        document.getElementById('ai-explain-btn').addEventListener('click', () => {
            currentAiMode = 'explain';
            modalTitle.innerText = "Interactive Explain ðŸŠ";
            modalTitle.className = "text-xl font-bold mb-2 text-orange-400";
            modalDesc.innerText = `Explain current diagram: ${activeDiagramId}`;
            promptModal.style.display = 'flex';
            promptInput.value = "";
            promptInput.focus();
        });

        closePromptBtn.addEventListener('click', () => { promptModal.style.display = 'none'; });

        confirmPromptBtn.addEventListener('click', async () => {
            const userInput = promptInput.value.trim();
            if (!userInput) return;
            promptModal.style.display = 'none';
            statusBar.style.opacity = '1';
            
            if (currentAiMode === 'generate') {
                statusBar.innerHTML = `<span class="loader"></span> Generating Diagram...`;
                await handleGenerate(userInput);
            } else {
                statusBar.innerHTML = `<span class="loader"></span> Analyzing...`;
                await handleExplain(userInput);
            }
        });

        async function handleGenerate(userInput) {
            const flowId = `flow_${Date.now()}`;
            const systemPrompt = `
                You are a 3D Flow Diagram Director.
                Create a JSON schema for a NEW diagram about: "${userInput}".
                Prefix all node IDs with "${flowId}_" (e.g., "${flowId}_start").
                Output JSON:
                {
                    "title": "Short Title",
                    "nodes": [ { "id": "${flowId}_n1", "label": "Start", "type": "capsule", "color": "#22c55e" } ],
                    "edges": [ { "from": 0, "to": 1 } ],
                    "animation": [
                        { 
                          "targetIndex": 0, "duration": 2000, "hold": 1500, 
                          "text": "Subtitle text", "codeSnippet": "Code info"
                        }
                    ]
                }
            `;
            const resultStr = await callGemini(userInput, systemPrompt);
            processAiResponse(resultStr, true, flowId, userInput);
        }

        async function handleExplain(userInput) {
            const sceneContext = objects
                .filter(o => o.userData.type !== 'label' && o.userData.diagramId === activeDiagramId)
                .map(o => ({ id: o.userData.id, label: o.userData.label, type: o.userData.type }));

            const explId = `expl_${Date.now()}`;
            const systemPrompt = `
                You are an Expert System Explainer. User Query: "${userInput}"
                Context Nodes: ${JSON.stringify(sceneContext)}
                1. Add NEW NODES to explain concepts. "category": "explain".
                2. New Node IDs MUST be unique (e.g. append "_${explId}").
                3. Generate an ANIMATION sequence using existing nodes + new nodes.
                Output JSON:
                {
                    "newNodes": [ { "id": "new_1_${explId}", "label": "Log", "type": "cube", "color": "#f97316", "category": "explain" } ],
                    "newEdges": [ { "fromId": "existing_id", "toId": "new_1_${explId}" } ],
                    "animation": [ { "targetId": "new_1_${explId}", "text": "Explanation...", "codeSnippet": "Details..." } ]
                }
            `;
            const resultStr = await callGemini(userInput, systemPrompt);
            processAiResponse(resultStr, false, activeDiagramId, userInput);
        }

        function processAiResponse(resultStr, isFullGen, id, query) {
            if (!resultStr) { statusBar.innerText = "AI Failed."; return; }
            try {
                const cleanJson = resultStr.replace(/```json/g, '').replace(/```/g, '').trim();
                const data = JSON.parse(cleanJson);

                if (isFullGen) {
                    buildNewFlow(data, id);
                } else {
                    appendExplanation(data, id, query);
                }
                
                statusBar.innerText = "Done! Press Play >";
                setTimeout(() => statusBar.style.opacity = '0', 3000);
            } catch (e) {
                console.error(e);
                alert("AI Parsing Error.");
                statusBar.style.opacity = '0';
            }
        }

        function buildNewFlow(data, flowId) {
            const startX = nextDiagramOffsetX;
            
            const diag = {
                id: flowId,
                name: data.title || `Diagram ${diagrams.length + 1}`,
                offsetX: startX,
                mainSequence: [],
                explanations: []
            };
            
            const createdMeshes = [];
            const spacingX = 7; const spacingZ = 6; const columns = 3; 

            data.nodes.forEach((node, index) => {
                const col = index % columns;
                const row = Math.floor(index / columns);
                const x = startX + (col * spacingX);
                const z = (row * spacingZ) - 5;
                const mesh = createMeshFromData(node, {x, y: 2, z}, 'standard', flowId);
                createdMeshes.push(mesh);
            });

            data.edges.forEach(edge => {
                if (createdMeshes[edge.from] && createdMeshes[edge.to]) {
                    createArrow(createdMeshes[edge.from], createdMeshes[edge.to]);
                }
            });

            if (data.animation) {
                diag.mainSequence = data.animation.map(step => ({
                    targetId: createdMeshes[step.targetIndex] ? createdMeshes[step.targetIndex].userData.id : null,
                    duration: step.duration || 2000, hold: step.hold || 1000,
                    text: step.text || "", codeSnippet: step.codeSnippet || ""
                })).filter(s => s.targetId);
            }

            diagrams.push(diag);
            
            const opt = document.createElement('option');
            opt.value = flowId; opt.text = diag.name;
            diagramSelect.appendChild(opt);
            diagramSelect.value = flowId;
            
            activeDiagramId = flowId;
            activeExplanationId = 'main';
            diagramSelect.dispatchEvent(new Event('change'));
            nextDiagramOffsetX += 50; 
        }

        function appendExplanation(data, diagramId, query) {
            const diag = diagrams.find(d => d.id === diagramId);
            if(!diag) return;

            const baseX = diag.offsetX;
            const explId = `expl_${Date.now()}`;
            
            const explanation = {
                id: explId,
                query: query,
                sequence: data.animation || [],
                nodeIds: [] 
            };

            // Add nodes specific to this explanation
            if (data.newNodes) {
                data.newNodes.forEach((node, i) => {
                    const pos = { x: baseX + (i * 6), y: 8, z: 8 }; 
                    const mesh = createMeshFromData(node, pos, 'explain', diagramId, explId);
                    explanation.nodeIds.push(mesh.userData.id);
                });
            }

            if (data.newEdges) {
                data.newEdges.forEach(edge => {
                    const source = objects.find(o => o.userData.id === edge.fromId);
                    const target = objects.find(o => o.userData.id === edge.toId);
                    if (source && target) createArrow(source, target);
                });
            }

            diag.explanations.push(explanation);
            
            // Force UI refresh and select this explanation
            updateExplanationUI();
            explanationSelect.value = explId;
            activeExplanationId = explId;
            updateCameraAndSequence();
            updateVisibility();
        }

        function createMeshFromData(nodeData, position, category, diagramId, explanationId = null) {
            let geo;
            switch(nodeData.type) {
                case 'sphere': geo = new THREE.SphereGeometry(1.2, 32, 32); break;
                case 'cylinder': geo = new THREE.CylinderGeometry(1, 1, 2.5, 32); break;
                case 'diamond': geo = new THREE.OctahedronGeometry(1.5, 0); break;
                case 'capsule': geo = new THREE.CapsuleGeometry(0.8, 1, 4, 16); break;
                default: geo = new THREE.BoxGeometry(2, 2, 2); break;
            }
            const mesh = addMesh(geo, nodeData.type, position, nodeData.color || '#3b82f6', category, diagramId, explanationId);
            if (nodeData.id) mesh.userData.id = nodeData.id;
            addLabel(nodeData.label, mesh);
            return mesh;
        }

        function deleteSelected() {
            if (!selectedObject) return;
            const obj = selectedObject;
            scene.remove(obj);
            const index = objects.indexOf(obj);
            if (index > -1) objects.splice(index, 1);
            for (let i = arrows.length - 1; i >= 0; i--) {
                if (arrows[i].source === obj || arrows[i].target === obj) {
                    scene.remove(arrows[i].group);
                    arrows.splice(i, 1);
                }
            }
            transformControl.detach();
            selectedObject = null;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAnimation();
            orbit.update();
            updateArrows();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>