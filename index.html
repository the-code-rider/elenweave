<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flow Diagram Playground v4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* Floating UI Panel */
        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 260px;
            z-index: 10;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* Top Right Info Panel (Code Block) */
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            color: #e0e0e0;
            z-index: 10;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            overflow: hidden;
        }
        .info-header {
            background: #333;
            padding: 8px 12px;
            font-weight: bold;
            font-family: 'Segoe UI', sans-serif;
            border-bottom: 1px solid #444;
            color: #a0aec0;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .info-content {
            padding: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            color: #a5f3fc; /* Cyan tint for code */
        }

        .tool-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .tool-btn {
            background: #333;
            border: 1px solid #555;
            color: #ddd;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            width: 100%;
        }

        .tool-btn.full-width { grid-column: span 2; }

        .tool-btn:hover { background: #444; border-color: #777; }
        .tool-btn.active { background: #3b82f6; border-color: #2563eb; color: white; }
        .tool-btn.danger:hover { background: #ef4444; border-color: #dc2626; }
        
        /* AI Gradient Button */
        .tool-btn.ai { 
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            border: 1px solid #8b5cf6;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .tool-btn.ai:hover { filter: brightness(1.1); box-shadow: 0 0 10px rgba(124, 58, 237, 0.3); }

        /* Animation Controls */
        .anim-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
        }
        .tool-btn.play { background: #059669; border-color: #047857; color: white; }
        .tool-btn.pause { background: #d97706; border-color: #b45309; color: white; }
        .tool-btn.stop { background: #dc2626; border-color: #b91c1c; color: white; }

        .divider { height: 1px; background: #444; margin: 4px 0; }
        .label-sm { font-size: 0.7rem; text-transform: uppercase; color: #888; letter-spacing: 0.05em; margin-bottom: 2px; }

        /* Color Picker & Toggles */
        .prop-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #222;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #444;
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }

        /* Toggle Switch */
        .toggle-switch { position: relative; display: inline-block; width: 34px; height: 18px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #f97316; } /* Orange for explain nodes */
        input:checked + .slider:before { transform: translateX(16px); }

        /* Status Bar & Subtitles */
        #status-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
        }

        #subtitle-overlay {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            padding: 16px 24px;
            border-radius: 8px;
            font-size: 1.1rem;
            color: #fff;
            text-align: center;
            max-width: 600px;
            border: 1px solid rgba(255,255,255,0.2);
            display: none;
            z-index: 15;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .modal-input {
            width: 100%;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0 20px 0;
            font-size: 1rem;
        }
        .modal-input:focus { outline: none; border-color: #3b82f6; }
        .modal-footer { display: flex; justify-content: flex-end; gap: 10px; }
        
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-panel">
        <h1 class="text-lg font-bold text-center text-blue-400">FlowBuilder 4.0</h1>
        
        <!-- AI Section -->
        <div class="label-sm text-purple-400 mt-1">AI Director</div>
        <div class="tool-section">
            <button class="tool-btn ai full-width" id="ai-generate-btn">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg>
                Generate Flow
            </button>
            <button class="tool-btn ai full-width" id="ai-explain-btn">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                Interactive Explain
            </button>
        </div>

        <div class="divider"></div>

        <!-- Filter Section -->
        <div class="label-sm text-orange-400">Filters</div>
        <div class="prop-row">
            <span class="text-xs text-gray-300">Show 'Explain' Nodes</span>
            <label class="toggle-switch">
                <input type="checkbox" id="toggle-explain" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="divider"></div>

        <!-- Animation Controls -->
        <div class="label-sm text-green-400">Animation</div>
        <div class="anim-controls">
            <button class="tool-btn play" id="anim-play" title="Play">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            </button>
            <button class="tool-btn pause" id="anim-pause" title="Pause">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
            </button>
            <button class="tool-btn stop" id="anim-stop" title="Stop">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="6" width="12" height="12"></rect></svg>
            </button>
        </div>

        <div class="divider"></div>

        <!-- Properties -->
        <div class="label-sm">Properties</div>
        <div class="prop-row">
            <span class="text-xs text-gray-400">Object Color</span>
            <input type="color" id="obj-color" value="#3b82f6">
        </div>

        <div class="divider"></div>

        <!-- Shapes -->
        <div class="label-sm">Shapes</div>
        <div class="tool-section">
            <button class="tool-btn" id="add-cube">Cube</button>
            <button class="tool-btn" id="add-sphere">Sphere</button>
            <button class="tool-btn" id="add-cylinder">DB</button>
            <button class="tool-btn" id="add-diamond">Decision</button>
            <button class="tool-btn" id="add-capsule">Start/End</button>
            <button class="tool-btn" id="add-text">Label</button>
        </div>

        <div class="divider"></div>

        <!-- Tools -->
        <div class="label-sm">Tools</div>
        <div class="tool-section">
            <button class="tool-btn full-width" id="mode-connect">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>
                Link Nodes
            </button>
            <button class="tool-btn danger full-width" id="delete-obj">
                Delete Selected
            </button>
        </div>
    </div>

    <div id="info-panel">
        <div class="info-header">Node Context / Code</div>
        <div class="info-content" id="info-content">Select a node or play animation...</div>
    </div>

    <div id="status-bar">Ready</div>
    <div id="subtitle-overlay"></div>

    <!-- Prompt Modal -->
    <div id="prompt-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-xl font-bold mb-2 text-purple-400" id="modal-title">Generate Flow âœ¨</h2>
            <p class="text-sm text-gray-400" id="modal-desc">Describe the process (e.g., "E-commerce checkout flow").</p>
            <input type="text" id="ai-prompt-input" class="modal-input" placeholder="Enter description...">
            <div class="modal-footer">
                <button class="tool-btn" id="close-prompt">Cancel</button>
                <button class="tool-btn ai" id="confirm-prompt">Go</button>
            </div>
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- Gemini API Setup ---
        const apiKey = ""; 
        const MODEL_NAME = "gemini-2.5-flash-preview-09-2025";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${apiKey}`;

        async function callGemini(promptText, systemInstruction = "") {
            try {
                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptText }] }],
                        systemInstruction: { parts: [{ text: systemInstruction }] }
                    })
                });

                if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "No response.";
            } catch (error) {
                console.error("Gemini API Error:", error);
                return null;
            }
        }

        // --- Core Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        
        const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x222222);
        scene.add(gridHelper);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- State ---
        const objects = [];
        const arrows = [];
        let selectedObject = null;
        let isConnectMode = false;
        let connectSource = null;
        let explainNodesVisible = true;
        
        // Animation State
        let animState = {
            isPlaying: false,
            isPaused: false,
            currentIndex: 0,
            startTime: 0,
            sequence: [], // [{ targetId, duration, hold, text, codeSnippet }]
            cameraStartPos: new THREE.Vector3(),
            cameraStartTarget: new THREE.Vector3(),
            targetPos: new THREE.Vector3(),
            targetLookAt: new THREE.Vector3(),
            lastStepTime: 0,
            phase: 'IDLE'
        };

        // --- Controls ---
        const orbit = new OrbitControls(camera, renderer.domElement);
        orbit.enableDamping = true;
        orbit.dampingFactor = 0.05;

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', function (event) {
            orbit.enabled = !event.value;
        });
        scene.add(transformControl);

        // --- Materials ---
        const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.4 });
        const arrowHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xffaa00, emissiveIntensity: 0.2 });

        // --- Object Creation ---

        function addMesh(geometry, type = 'cube', position = null, colorHex = '#3b82f6', category = 'standard') {
            const x = position ? position.x : (Math.random() - 0.5) * 4;
            const z = position ? position.z : (Math.random() - 0.5) * 4;
            const y = position ? position.y : 2;
            
            const material = new THREE.MeshStandardMaterial({ 
                color: colorHex, 
                roughness: 0.3, 
                metalness: 0.2 
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            mesh.userData = { 
                type: type, 
                id: Math.random().toString(36).substr(2, 9), 
                label: "",
                baseColor: colorHex,
                category: category // 'standard' or 'explain'
            };
            
            scene.add(mesh);
            objects.push(mesh);
            
            // Check visibility filter immediately
            if (category === 'explain' && !explainNodesVisible) {
                mesh.visible = false;
                // Also hide any attached labels? Handled in loop
            }
            
            return mesh;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.roundRect(10, 10, 492, 108, 30);
            ctx.fill();
            
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 6;
            ctx.stroke();

            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            return new THREE.CanvasTexture(canvas);
        }

        function addLabel(text, parentMesh = null) {
            const texture = createTextTexture(text);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(4, 1, 1);
            sprite.userData = { type: 'label' };

            if (parentMesh) {
                let yOffset = 2;
                if (parentMesh.geometry.type === 'CylinderGeometry') yOffset = 2.5;
                if (parentMesh.geometry.type === 'CapsuleGeometry') yOffset = 2.5;

                sprite.position.set(0, yOffset, 0);
                parentMesh.add(sprite);
                parentMesh.userData.label = text;
            } else {
                sprite.position.set(0, 3, 0);
                scene.add(sprite);
                objects.push(sprite);
                selectObject(sprite);
            }
            return sprite;
        }

        // --- Helpers ---
        document.getElementById('add-cube').addEventListener('click', () => addMesh(new THREE.BoxGeometry(2, 2, 2), 'cube', null, document.getElementById('obj-color').value));
        document.getElementById('add-sphere').addEventListener('click', () => addMesh(new THREE.SphereGeometry(1.2, 32, 32), 'sphere', null, document.getElementById('obj-color').value));
        document.getElementById('add-cylinder').addEventListener('click', () => addMesh(new THREE.CylinderGeometry(1, 1, 2.5, 32), 'cylinder', null, document.getElementById('obj-color').value));
        document.getElementById('add-diamond').addEventListener('click', () => addMesh(new THREE.OctahedronGeometry(1.5, 0), 'diamond', null, document.getElementById('obj-color').value));
        document.getElementById('add-capsule').addEventListener('click', () => addMesh(new THREE.CapsuleGeometry(0.8, 1, 4, 16), 'capsule', null, document.getElementById('obj-color').value));
        document.getElementById('add-text').addEventListener('click', () => {
            const text = prompt("Enter label text:", "Node");
            if (text) addLabel(text);
        });

        // --- Connections ---
        function createArrow(source, target) {
            const arrowGroup = new THREE.Group();
            const shaftGeo = new THREE.CylinderGeometry(0.08, 0.08, 1, 8);
            shaftGeo.rotateX(Math.PI / 2);
            shaftGeo.translate(0, 0, 0.5);
            const shaft = new THREE.Mesh(shaftGeo, arrowMaterial);
            
            const headGeo = new THREE.ConeGeometry(0.35, 0.8, 12);
            headGeo.rotateX(Math.PI / 2);
            const head = new THREE.Mesh(headGeo, arrowHeadMaterial);
            
            arrowGroup.add(shaft);
            arrowGroup.add(head);
            scene.add(arrowGroup);
            
            // Assign category based on source node
            arrowGroup.userData = { category: source.userData.category || 'standard' };

            arrows.push({ group: arrowGroup, source, target, shaft, head });
            
            // Check visibility
            if (arrowGroup.userData.category === 'explain' && !explainNodesVisible) {
                arrowGroup.visible = false;
            }
        }

        function updateArrows() {
            arrows.forEach(arrow => {
                // If either connected node is hidden (deleted or invisible), hide arrow
                if (!arrow.source.parent || !arrow.target.parent || !arrow.source.visible || !arrow.target.visible) {
                    arrow.group.visible = false;
                    return;
                }
                
                // Restore visibility if it was hidden due to parent state but now valid
                // ONLY if category filter allows it
                if ((arrow.group.userData.category === 'standard') || 
                    (arrow.group.userData.category === 'explain' && explainNodesVisible)) {
                    arrow.group.visible = true;
                }

                const start = arrow.source.position.clone();
                const end = arrow.target.position.clone();
                const distance = start.distanceTo(end);
                arrow.group.position.copy(start);
                arrow.group.lookAt(end);
                const headLength = 0.8;
                const shaftLength = Math.max(0, distance - headLength);
                arrow.shaft.scale.set(1, 1, shaftLength);
                arrow.head.position.set(0, 0, distance - (headLength * 0.5));
            });
        }

        // --- UI Features: Toggle Explain Nodes ---
        document.getElementById('toggle-explain').addEventListener('change', (e) => {
            explainNodesVisible = e.target.checked;
            
            // Toggle Mesh Visibility
            objects.forEach(obj => {
                if (obj.userData.category === 'explain') {
                    obj.visible = explainNodesVisible;
                }
            });

            // Arrows update automatically in updateArrows loop based on node visibility
        });

        // --- Interaction ---
        const colorPicker = document.getElementById('obj-color');
        colorPicker.addEventListener('input', (e) => {
            if (selectedObject && selectedObject.userData.type !== 'label') {
                selectedObject.material.color.set(e.target.value);
                selectedObject.userData.baseColor = e.target.value;
            }
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function selectObject(obj) {
            if (selectedObject && selectedObject.userData.type !== 'label' && selectedObject !== connectSource) {
                selectedObject.material.emissive.setHex(0x000000);
            }
            selectedObject = obj;
            if (selectedObject) {
                transformControl.attach(selectedObject);
                if (selectedObject.userData.type !== 'label') {
                    if (selectedObject !== connectSource) selectedObject.material.emissive.setHex(0x333333);
                    colorPicker.value = '#' + selectedObject.material.color.getHexString();
                }
                // Update info panel manually on click
                document.getElementById('info-content').innerText = 
                    `ID: ${obj.userData.id}\nType: ${obj.userData.type}\nLabel: ${obj.userData.label || 'None'}\nCategory: ${obj.userData.category}`;
            } else {
                transformControl.detach();
            }
        }

        window.addEventListener('pointerdown', (event) => {
            if (event.target.tagName !== 'CANVAS') return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(objects.filter(o => o.visible)); // Only raycast visible
            if (intersects.length > 0) {
                if (isConnectMode) handleConnectionClick(intersects[0].object);
                else selectObject(intersects[0].object);
            } else {
                if (!isConnectMode) selectObject(null);
            }
        });

        const connectBtn = document.getElementById('mode-connect');
        const statusBar = document.getElementById('status-bar');
        connectBtn.addEventListener('click', () => {
            isConnectMode = !isConnectMode;
            if (isConnectMode) {
                connectBtn.classList.add('active');
                statusBar.style.opacity = '1';
                statusBar.innerText = "Select Source Node";
                transformControl.detach();
            } else {
                resetConnectMode();
            }
        });

        function handleConnectionClick(obj) {
            if(obj.userData.type === 'label') return;
            if (!connectSource) {
                connectSource = obj;
                obj.material.emissive.setHex(0x00ff00);
                statusBar.innerText = "Select Target Node";
            } else {
                if (connectSource !== obj) {
                    createArrow(connectSource, obj);
                    resetConnectMode();
                } else resetConnectMode();
            }
        }

        function resetConnectMode() {
            isConnectMode = false;
            if (connectSource && connectSource.userData.type !== 'label') connectSource.material.emissive.setHex(0x000000);
            connectSource = null;
            connectBtn.classList.remove('active');
            statusBar.style.opacity = '0';
            if(selectedObject) transformControl.attach(selectedObject);
        }

        // --- Animation Logic ---
        const playBtn = document.getElementById('anim-play');
        const pauseBtn = document.getElementById('anim-pause');
        const stopBtn = document.getElementById('anim-stop');
        const subtitleOverlay = document.getElementById('subtitle-overlay');
        const infoPanel = document.getElementById('info-panel');
        const infoContent = document.getElementById('info-content');

        playBtn.addEventListener('click', startAnimation);
        pauseBtn.addEventListener('click', () => { animState.isPaused = !animState.isPaused; });
        stopBtn.addEventListener('click', stopAnimation);

        function startAnimation() {
            if (animState.sequence.length === 0) {
                // Auto-generate
                animState.sequence = objects
                    .filter(o => o.userData.type !== 'label' && o.visible) // Only animate visible nodes
                    .map(o => ({ 
                        targetId: o.userData.id, 
                        duration: 1500, 
                        hold: 1000, 
                        text: o.userData.label || "Viewing Node",
                        codeSnippet: `// Node: ${o.userData.label}\n// Type: ${o.userData.type}`
                    }));
            }
            
            if (animState.sequence.length === 0) return;

            if (!animState.isPlaying) {
                animState.isPlaying = true;
                animState.isPaused = false;
                animState.currentIndex = 0;
                orbit.enabled = false;
                transformControl.detach();
                subtitleOverlay.style.display = 'block';
                infoPanel.style.display = 'block';
                prepareStep(0);
            } else if (animState.isPaused) {
                animState.isPaused = false;
            }
        }

        function stopAnimation() {
            animState.isPlaying = false;
            animState.isPaused = false;
            orbit.enabled = true;
            subtitleOverlay.style.display = 'none';
            infoPanel.style.display = 'none';
            statusBar.innerText = "Ready";
            statusBar.style.opacity = '0';
        }

        function prepareStep(index) {
            if (index >= animState.sequence.length) {
                stopAnimation();
                return;
            }

            const step = animState.sequence[index];
            const targetObj = objects.find(o => o.userData.id === step.targetId);

            // Skip if node is deleted or hidden by filter
            if (!targetObj || !targetObj.visible) {
                prepareStep(index + 1);
                return;
            }

            animState.cameraStartPos.copy(camera.position);
            animState.cameraStartTarget.copy(orbit.target);
            
            const offset = new THREE.Vector3(5, 5, 5); 
            animState.targetPos.copy(targetObj.position).add(offset);
            animState.targetLookAt.copy(targetObj.position);
            
            animState.phase = 'MOVING';
            animState.lastStepTime = Date.now();
            
            subtitleOverlay.innerText = step.text;
            infoContent.innerText = step.codeSnippet || "// No details available";
            
            statusBar.style.opacity = '1';
            statusBar.innerText = `Step ${index + 1}/${animState.sequence.length}`;
            
            selectObject(targetObj);
        }

        function updateAnimation() {
            if (!animState.isPlaying || animState.isPaused) return;

            const now = Date.now();
            const step = animState.sequence[animState.currentIndex];
            const elapsed = now - animState.lastStepTime;

            if (animState.phase === 'MOVING') {
                const progress = Math.min(elapsed / step.duration, 1);
                const ease = 1 - Math.pow(1 - progress, 3);

                camera.position.lerpVectors(animState.cameraStartPos, animState.targetPos, ease);
                orbit.target.lerpVectors(animState.cameraStartTarget, animState.targetLookAt, ease);

                if (progress >= 1) {
                    animState.phase = 'HOLDING';
                    animState.lastStepTime = now;
                }
            } else if (animState.phase === 'HOLDING') {
                if (elapsed >= step.hold) {
                    animState.currentIndex++;
                    prepareStep(animState.currentIndex);
                }
            }
        }

        // --- AI Modal & Features ---
        const promptModal = document.getElementById('prompt-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalDesc = document.getElementById('modal-desc');
        const promptInput = document.getElementById('ai-prompt-input');
        const confirmPromptBtn = document.getElementById('confirm-prompt');
        const closePromptBtn = document.getElementById('close-prompt');
        
        let currentAiMode = 'generate'; // 'generate' or 'explain'

        document.getElementById('ai-generate-btn').addEventListener('click', () => {
            currentAiMode = 'generate';
            modalTitle.innerText = "Generate Flow âœ¨";
            modalTitle.className = "text-xl font-bold mb-2 text-purple-400";
            modalDesc.innerText = "Describe the process to create from scratch.";
            promptModal.style.display = 'flex';
            promptInput.value = "";
            promptInput.focus();
        });

        document.getElementById('ai-explain-btn').addEventListener('click', () => {
            currentAiMode = 'explain';
            modalTitle.innerText = "Interactive Explain ðŸŠ";
            modalTitle.className = "text-xl font-bold mb-2 text-orange-400";
            modalDesc.innerText = "Ask a question about your flow (e.g. 'What happens on error?'). AI will add nodes if needed.";
            promptModal.style.display = 'flex';
            promptInput.value = "";
            promptInput.focus();
        });

        closePromptBtn.addEventListener('click', () => { promptModal.style.display = 'none'; });

        confirmPromptBtn.addEventListener('click', async () => {
            const userInput = promptInput.value.trim();
            if (!userInput) return;
            promptModal.style.display = 'none';
            statusBar.style.opacity = '1';
            
            if (currentAiMode === 'generate') {
                statusBar.innerHTML = `<span class="loader"></span> Generative AI Working...`;
                await handleGenerate(userInput);
            } else {
                statusBar.innerHTML = `<span class="loader"></span> Analyzing & explaining...`;
                await handleExplain(userInput);
            }
        });

        async function handleGenerate(userInput) {
            const systemPrompt = `
                You are a 3D Flow Diagram Director.
                Create a JSON schema.
                Shapes: "cube", "sphere", "cylinder", "diamond", "capsule".
                Colors: Semantic Hex.
                Output JSON:
                {
                    "nodes": [ { "id": "n1", "label": "Start", "type": "capsule", "color": "#22c55e" } ],
                    "edges": [ { "from": 0, "to": 1 } ],
                    "animation": [
                        { 
                          "targetIndex": 0, "duration": 2000, "hold": 1500, 
                          "text": "Subtitle text",
                          "codeSnippet": "Pseudo-code or technical details displayed in panel"
                        }
                    ]
                }
            `;
            
            const resultStr = await callGemini(userInput, systemPrompt);
            processAiResponse(resultStr, true);
        }

        async function handleExplain(userInput) {
            // Serialize current scene to context
            const sceneContext = objects.filter(o => o.userData.type !== 'label').map(o => ({
                id: o.userData.id,
                label: o.userData.label,
                type: o.userData.type
            }));

            const systemPrompt = `
                You are an Expert System Explainer.
                User Query: "${userInput}"
                Current Scene Nodes: ${JSON.stringify(sceneContext)}

                1. You may ADD NEW NODES to explain the concept (e.g. Error Handlers, Logs). 
                   Mark new nodes with "category": "explain".
                   Use distinct color #f97316 (Orange) for new explain nodes.
                2. Generate an ANIMATION sequence that walks through existing relevant nodes AND your new nodes.
                3. Provide "codeSnippet" for each step.

                Output JSON:
                {
                    "newNodes": [ { "id": "ex1", "label": "Error Log", "type": "cube", "color": "#f97316", "category": "explain" } ],
                    "newEdges": [ { "fromId": "n1", "toId": "ex1" } ],
                    "animation": [
                         { 
                           "targetId": "n1", "duration": 2000, "hold": 1000, 
                           "text": "Standard processing...", "codeSnippet": "process()" 
                         },
                         { 
                           "targetId": "ex1", "duration": 2000, "hold": 2000, 
                           "text": "If failure occurs, we log here.", "codeSnippet": "try {\n  process()\n} catch(e) {\n  logger.error(e)\n}" 
                         }
                    ]
                }
            `;

            const resultStr = await callGemini(userInput, systemPrompt);
            processAiResponse(resultStr, false);
        }

        function processAiResponse(resultStr, isFullGen) {
            if (!resultStr) {
                statusBar.innerText = "AI Failed.";
                return;
            }
            
            try {
                const cleanJson = resultStr.replace(/```json/g, '').replace(/```/g, '').trim();
                const data = JSON.parse(cleanJson);

                if (isFullGen) {
                    // Full Generation
                    buildFlowFromAI(data);
                } else {
                    // Explanation (Append)
                    appendExplanation(data);
                }
                
                statusBar.innerText = "Ready. Press Play >";
                setTimeout(() => statusBar.style.opacity = '0', 3000);
            } catch (e) {
                console.error(e);
                alert("AI Parsing Error.");
                statusBar.style.opacity = '0';
            }
        }

        function buildFlowFromAI(data) {
            while(objects.length > 0) { selectedObject = objects[0]; deleteSelected(true); }
            arrows.forEach(a => scene.remove(a.group));
            arrows.length = 0;

            const createdMeshes = [];
            const spacingX = 7;
            const spacingZ = 6;
            const columns = 3; 

            data.nodes.forEach((node, index) => {
                const col = index % columns;
                const row = Math.floor(index / columns);
                const x = (col * spacingX) - ((columns * spacingX) / 2) + (row % 2 === 0 ? 0 : 3);
                const z = (row * spacingZ) - 5;
                
                const mesh = createMeshFromData(node, {x, y: 2, z});
                createdMeshes.push(mesh);
            });

            data.edges.forEach(edge => {
                if (createdMeshes[edge.from] && createdMeshes[edge.to]) {
                    createArrow(createdMeshes[edge.from], createdMeshes[edge.to]);
                }
            });

            if (data.animation) {
                animState.sequence = data.animation.map(step => ({
                    targetId: createdMeshes[step.targetIndex] ? createdMeshes[step.targetIndex].userData.id : null,
                    duration: step.duration || 2000,
                    hold: step.hold || 1000,
                    text: step.text || "",
                    codeSnippet: step.codeSnippet || ""
                })).filter(s => s.targetId);
            }
        }

        function appendExplanation(data) {
            // 1. Add New Nodes
            // Find a spot to put them. Let's put them to the right of existing bounds or interleaved.
            // Simple strategy: Place them at Z=10 (foreground) spread out.
            const startX = -5;
            const spacing = 6;

            if (data.newNodes) {
                // Ensure explain nodes toggle is ON so user sees them
                document.getElementById('toggle-explain').checked = true;
                explainNodesVisible = true;

                data.newNodes.forEach((node, i) => {
                    const pos = { x: startX + (i * spacing), y: 2, z: 8 }; 
                    createMeshFromData(node, pos);
                });
            }

            // 2. Add New Edges (requires ID lookup)
            if (data.newEdges) {
                data.newEdges.forEach(edge => {
                    const source = objects.find(o => o.userData.id === edge.fromId);
                    const target = objects.find(o => o.userData.id === edge.toId);
                    if (source && target) createArrow(source, target);
                });
            }

            // 3. Set Animation Sequence
            if (data.animation) {
                animState.sequence = data.animation;
                // Auto-play to show the explanation
                stopAnimation(); // Reset
                startAnimation();
            }
        }

        function createMeshFromData(nodeData, position) {
            let geo;
            switch(nodeData.type) {
                case 'sphere': geo = new THREE.SphereGeometry(1.2, 32, 32); break;
                case 'cylinder': geo = new THREE.CylinderGeometry(1, 1, 2.5, 32); break;
                case 'diamond': geo = new THREE.OctahedronGeometry(1.5, 0); break;
                case 'capsule': geo = new THREE.CapsuleGeometry(0.8, 1, 4, 16); break;
                default: geo = new THREE.BoxGeometry(2, 2, 2); break;
            }
            
            const mesh = addMesh(geo, nodeData.type, position, nodeData.color || '#3b82f6', nodeData.category || 'standard');
            if (nodeData.id) mesh.userData.id = nodeData.id;
            addLabel(nodeData.label, mesh);
            return mesh;
        }

        function deleteSelected(force = false) {
            if (!selectedObject && !force) return;
            const obj = selectedObject;
            scene.remove(obj);
            const index = objects.indexOf(obj);
            if (index > -1) objects.splice(index, 1);
            for (let i = arrows.length - 1; i >= 0; i--) {
                if (arrows[i].source === obj || arrows[i].target === obj) {
                    scene.remove(arrows[i].group);
                    arrows.splice(i, 1);
                }
            }
            transformControl.detach();
            selectedObject = null;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateAnimation();
            orbit.update();
            updateArrows();
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>